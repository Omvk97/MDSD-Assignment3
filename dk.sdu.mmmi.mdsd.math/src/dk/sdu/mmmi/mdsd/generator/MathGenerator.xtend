/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VariableUse
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Program
import dk.sdu.mmmi.mdsd.math.ExternalMethod
import dk.sdu.mmmi.mdsd.math.ExternalMethodCall
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Parenthesis

class MathGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(Program).next
		generateProgram(program, fsa)
	}
	
	def static generateProgram(Program program, IFileSystemAccess2 fsa) {
		var fileName = "math_expression/" + program.name + ".java"
		var fileContents = generateFileContents(program)
		fsa.generateFile(fileName, fileContents)
	}
	
	def static generateFileContents(Program program) {
		var className = program.name
		var externalMethodsHaveBeenDefined = program.externalMethods.size != 0
		return '''
		package math_expression;
		
		public class «className» {
			
			«FOR variable : program.math.variables»
			public int «variable.name»;
			«ENDFOR»
			«IF externalMethodsHaveBeenDefined»
			
			private External external;
			
			public «className»(External external) {
				this.external = external;
			}
			«ENDIF»
			
			public void compute() {
				«FOR variable : program.math.variables»
				this.«variable.name» = «variable.expression.javaCompileRepresentation»;
				«ENDFOR»
			}
			
			«IF externalMethodsHaveBeenDefined»
			// External Method Interfaces
			«program.generateExternalMethodInterfaces»
			«ENDIF»
		}
		'''
	}
	
	def static String javaCompileRepresentation(Expression expression) {
		switch expression {
			MathNumber: expression.value.toString
			Plus: '''«expression.left.javaCompileRepresentation» + «expression.right.javaCompileRepresentation»'''
			Minus:  '''«expression.left.javaCompileRepresentation» - «expression.right.javaCompileRepresentation»'''
			Mult: '''«expression.left.javaCompileRepresentation» * «expression.right.javaCompileRepresentation»'''
			Div: '''«expression.left.javaCompileRepresentation» / «expression.right.javaCompileRepresentation»'''
			Parenthesis: '''(«expression.expression.javaCompileRepresentation»)'''
			LetBinding: '''«expression.body.javaCompileRepresentation»'''
			VariableUse: {
				var ref = expression.ref
				if (ref instanceof LetBinding) {
					return '''(«ref.binding.javaCompileRepresentation»)'''
				}
				return ref.name
			}
			ExternalMethodCall: '''this.external.«expression.method.name»(«FOR argument: expression.arguments SEPARATOR ', '»«argument.javaCompileRepresentation»«ENDFOR»)'''
		}
	}

	def static generateExternalMethodInterfaces(Program program) {
		
		return '''
		public interface External {
			«FOR exMethod : program.externalMethods»
			public int «exMethod.name»(«exMethod.generateExternalInterfaceParameters»);
			«ENDFOR»
		}
		'''
	}
	
	def static generateExternalInterfaceParameters(ExternalMethod externalMethod) {
		var counter = 0;
		return '''«FOR type : externalMethod.types SEPARATOR ', '»«type» «externalMethod.name»«type.toFirstUpper»«counter++»«ENDFOR»'''
	}
	
}
